*This project has been created as part of the 42 curriculum by laviles.*

# ðŸ”„ Push_swap

### Because Swap_push isnâ€™t as natural

<p align="center">
    <img src="https://img.shields.io/badge/Score-125%2F100-success?style=for-the-badge&logo=42" alt="Score 125/100">
    <img src="https://img.shields.io/badge/Language-C-blue?style=for-the-badge&logo=c" alt="Language C">
    <img src="https://img.shields.io/badge/Status-Completed-success?style=for-the-badge" alt="Status Completed">
</p>



## ðŸŽ¯ Project Objectives

**Push_swap** is an algorithmic project that involves sorting a stack of data using an auxiliary stack and a limited set of instructions. The main objective is to design and implement an efficient algorithm in C that achieves the sort with the minimum number of operations.

The project focuses on:

* **Stack Management**: Implementation of dynamic data structures.


* **Algorithm Complexity**: Movement optimization to meet specific performance requirements ( or similar).


* **Data Classification**: Implementing sorting logic adapted to specific constraints.



## âš™ï¸ The Rules

We have two stacks (**a** and **b**) and a specific instruction set:

* **Push (`pa`, `pb`)**: Move the top element from one stack to another.


* **Swap (`sa`, `sb`)**: Swap the first two elements at the top of a stack.


* **Rotate (`ra`, `rb`)**: Shift up all elements by 1; the first becomes the last.


* **Reverse Rotate (`rra`, `rrb`)**: Shift down all elements by 1; the last becomes the first.



## ðŸ§  My Approach (Personal Logic)

I implemented a chunk-based sorting algorithm, commonly known as **k-sort**. This strategy utilizes a **Dynamic Window** that adapts as the sorting progresses, optimizing the number of movements required.

### Advanced Parsing & Memory Management

Unlike common implementations that rely on `ft_strjoin` and `ft_split`, I developed a **custom Tokenizer** approach:

* **Direct Stack Building**: My logic extracts values, validates them, and builds the stack simultaneously.
* **Evolution of Knowledge**: Having recently finished *Get_next_line*, I implemented a "get_next_number" logic. This allowed me to master the use of **static variables** and reinforce my heap memory management and pointer manipulation skills.
* **Hybrid Input Support**: The parser is robust enough to handle multiple formatsâ€”quoted strings, individual arguments, or mixed inputs â€”using a custom `strtok` implementation.



## ðŸ› ï¸ Instructions

### Prerequisites

You need a **Unix-based environment** (Linux/macOS) with `cc` and `make` installed.

### Installation & Usage

1. **Clone & Compile**:
This command clones the repository, initializes the necessary submodules (like libft), and compiles the project using the Makefile to generate the push_swap binary in a single automated step.

```bash
git clone https://github.com/lautarolma/push_swap.git && cd push_swap && git submodule update --init --recursive && make

```

2. **Run**:
You can replace the numbers in the variable below with any amount of integers you wish to sort.

```bash
ARG="3 1 2 5 4"; ./push_swap $ARG

```

> **Pro Tip:** You can pass hundreds of numbers by using `ARG=$(seq 1 500 | shuf)`.

---



## ðŸ† Bonus: Checker Program

The bonus consists of a custom checker that verifies if the sequence of instructions generated by push_swap actually sorts the stack.
1. **Compilation**

To compile the checker, use the dedicated rule:
```bash
make bonus

```

2. **Execution**

To verify the sorting logic, store your numbers in a variable and pipe the instructions to the checker. This ensures both programs receive the exact same input:
```bash
ARG="3 2 1 0"; ./push_swap $ARG | ./checker $ARG

```

3. **Expected Output**

The program will display the list of instructions performed, followed by one of these results:

   * **`OK`**: The instructions successfully sorted the stack and the stack B is empty.

   * **`KO`**: The stack is not sorted after executing the instructions.

   * **`Error`**: One or more arguments are invalid (non-integers, duplicates, or out of range).



## ðŸ“š Resources & Credits

This project is the result of extensive research and logic design. While the code is **entirely my own implementation**, I leveraged the following resources for learning and architectural inspiration:

* **Logic & Strategy:**
* **YouTube:** [Oceano - Push_swap project](https://youtu.be/OaG81sDEpVk?si=JppUGYoOw63sNEax).
* **AI Mentorship & Usage:** **Gemini** & **ChatGPT** were utilized for strategic tutoring, algorithm conceptualization, and README formatting.
* Strategic Tutoring: Used to understand the mathematical logic behind the k-sort algorithm and the efficiency of different chunk sizes based on the number of elements
* Documentation: Used to help structure and format this README to ensure it meets the clarity standards for peers and recruiters.


* **Technical References:**
* **Parsing inspiration:** [Aletheios42](https://github.com/Aletheios42).
* **Structural reference:** [7pixeles](https://github.com/7pixeles).
* **Testing tools:** [gumoreno-code](https://github.com/gumoreno-code).


* **Peer Recognition:**
* Special thanks to **manguita** and **daviles** for their mentorship in learning and architectural design.
* Grateful to **alepinto** for his invaluable help in understanding and debugging the `strtok` implementation.





> **Note:** Every line of code was written manually. I used these references to understand best practices, ensuring no "copy-pasting" was involved in the final product.
